# ExecuTorch 工作原理

在高层次上，使用 ExecuTorch 在边缘设备（如笔记本电脑、手机、可穿戴设备和物联网设备）上运行 PyTorch 模型有三个步骤。

1. 导出模型：第一步是将 PyTorch 程序捕获为 graph，这是模型的新表示形式，可以用一系列算子（如加法、乘法或卷积）来表达。这个过程安全地保留了原始 PyTorch 程序的语义。这种表示形式是使模型能够在具有低内存和/或低计算的边缘用例上运行的第一步。
2. 将导出的模型编译成 ExecuTorch 程序：给定第一步中导出的模型，将其转换为 ExecuTorch 程序的可执行格式，该运行时可以使用它进行推理。这一步提供了各种优化的入口点，例如压缩模型（例如量化）以减小大小，并将子图进一步编译为专用硬件加速器以减少延迟。它还提供了一个内存规划的入口点，即有效地规划中间张量的位置，以减少运行时内存占用。
3. 在目标设备上运行 ExecuTorch 程序：给定输入（例如表示为输入激活张量的图像），ExecuTorch 运行时加载 ExecuTorch 程序，执行程序表示的指令，并计算输出。这一步是高效的，因为（1）运行时轻量级，（2）已经在步骤1和2中计算出了有效的执行计划，使得可以进行高性能推理。此外，核心运行时的可移植性使得即使在高度受限的设备上也能进行高性能执行。

```{admonition} ExecuTorch 主要优势
ExecuTorch 为需要将机器学习模型部署到边缘设备的工程师提供了以下优势：

1. 强大而可靠的导出功能。导出使用 {func}`torch.export`，它使用与 PyTorch 2.x 相同的技术来捕获 PyTorch 程序以进行快速执行。虽然急切模式灵活并允许在 Python 中进行实验，但如果 Python 不可用或无法提供高效的执行，则可能无法正常工作。导出流程生成的导出中间表示（Export IR）可以描述 PyTorch 模型中的广泛动态性，包括控制流和动态形状，这使得它成为完全捕获现有PyTorch模型的强大工具，而无需太多努力。
2. 算子标准化。在图导出过程中，图中的节点代表诸如加法、乘法或卷积等算子。这些算子是称为Core ATen Op集的小型标准化列表的一部分。大多数PyTorch程序可以在导出时使用这个小的算子集分解成图。算子列表的小型标准化减少了第三方算子库以及加速器后端需要覆盖的表面积，以便运行为ExecuTorch导出的模型。ExecuTorch运行时附带了一个这样的库，称为可移植算子库，它实现了Core ATen opset。
3. 编译器接口（也称为委托）和开源生态系统的标准化。除了上述算子标准化之外，ExecuTorch还具有委托给编译器的标准接口。这允许第三方供应商和编译器实现针对其专用硬件的图（部分或全部）的编译和执行的接口和API入口点。这提供了更大的硬件支持和性能优化灵活性，以及与PyTorch开源生态系统的更轻松集成，用于设备上的AI。
4. 第一方SDK和工具链。由于上述标准化工作，可以为ExecuTorch构建统一的第一方SDK，开发人员可以使用相同的SDK导出、编译和部署广泛的目标设备，如iOS、Android和微控制器，从而简化流程并获得更高的生产力。此外，该SDK还提供调试和分析功能，可以轻松检查中间状态，这是大多数开发人员工作流程的核心部分。
5. 无需中间转换。ExecuTorch的主要设计原则是允许开发人员在目标设备上运行他们的模型，而无需转换为第三方中间表示形式。这消除了设备开发人员在处理这些转换步骤时通常面临的许多问题，例如缺乏调试性和分析能力、需要熟悉特定于硬件的工具以及由于转换步骤失败而导致模型无法运行等问题。
6. 易于定制。开发人员可以通过应用自定义技术（如链接高性能算子实现或根据存储和延迟权衡自定义内存规划）来优化其在目标架构上的部署，以获得更好的性能增益。这种级别的定制是通过标准化导出图中的编译器传递接口和注册API来实现的。
7. 低开销运行时和执行。ExecuTorch运行时是用C++编写的，非常高效，并且可以在广泛的体系结构上运行，包括Linux、iOS、Android、嵌入式系统和裸机硬件，几乎不需要额外的设置或配置。它能够仅链接模型所需的算子，从而产生最小的运行时二进制文件大小。它还能够在提前编译和内存规划阶段以低延迟运行，因为运行时只负责执行（例如调用conv操作并将结果保存在内存位置X）。

以上突出显示了ExecuTorch在三个主要类别中的主要优势：可移植性、生产力和性能。我们认为它是在移动和边缘计算平台上启用设备AI的理想选择。
```
